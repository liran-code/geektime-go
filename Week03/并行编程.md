# 并行编程 Go 语言实践 —— concurrency

[toc]

- [Goroutine](#Goroutine)
- [Memory model](#Memory-model)
- [Package sunc](#Package-sunc)
- [chan](#chan)
- [Package context](#Package-context)
- [References](#References)


重点：

goroutine 生命周期

内存模型 原子


atomic.Add() 原子自增

MESI 协议

## Goroutine

### processes 和 Threads

操作系统会为该应用程序创建一个进程。作为一个应用程序，它像一个为所有资源而运行的容器。这些资源包括内存地址空间、文件句柄、设备和线程。

线程是操作系统调度的一种执行路径，用于在处理器执行我们在函数中编写的代码。当该线程终止时，进程终止。这是因为主进程是应用程序的原点。然后，主线程可以依次启动更多的线程，而这些线程可以启动更多的线程。

无论线程属于哪个进程，操作系统都会安排线程在可用处理器上运行。每个操作系统都有自己的算法来做出这些决定。

### Goroutines and Parallelism（并发）

Go 语言层面支持 go 关键字，可以快速的让一个函数创建为 goroutine，我们可以认为 main 函数就是作为 goroutine 执行的。操作系统调度线程在可用处理器上运行，Go 运行时调度 goroutine 在绑定到单个操作系统线程的 **逻辑处理器（P）** 中运行。即使使用这个单一的逻辑处理器和操作系统线程，也可以调度数十万 goroutine 以惊人的效率和性能并发运行。

> P 像队列一样，绑定到一个（多个）线程（M）上，队列中挂载了很多个 goroutine，像排着队一样在运行，所有 goroutine 是非常轻量的，可以被大量的创建，goroutine 大量的创建只会保存在内存中，是在 runtime 里模仿成线程的内存结构的一个特殊结构体存在。 

**Concurrency is not Parallelism.**

并发不是并行。

并行是指两个或多个线程同时在不同的处理器执行代码。如果将运行时配置为使用多个逻辑处理器，则调度程序将在这些逻辑处理器之间分配 goroutine，这将导致 goroutine 在不同的操作系统线程上运行。但是，要获取真正的并行性，您需要在具有多个物理处理器的计算机上运行程序。否则，goroutine 将针对单个物理处理器并发运行，即使 Go 运行时使用多个逻辑处理器。

> 并行 -> 不同的执行单元
> 
> 并发 -> 多核心、同时运行

### Keep yourself busy or do the work yourself

空的 select 语句将永远阻塞。

```go
package main

import(
    "fmt"
    "log"
    "net/http"
)

func main(){
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintln(w, "Hello, GopherCon SG")    
    })
    go func(){ //完全不知道什么时候正常退出，因为main函数感知不到
        if err := http.ListenAndServer(":8080", nil); err != nil {
            log.Fatal(err)
        }
    }()

    select {} //不鼓励这种写法
}
```

如果你的 goroutine 在从另一个 goroutine 获得结果之前无法取得进展，那么通常情况下，你自己去做这项工作比委托它（go func()）更简单。

这通常消除了将结果从 goroutine 返回到其启动器所需的大量状态跟踪和 chan 操作。

```go
package main

import(
    "fmt"
    "log"
    "net/http"
)

func main(){
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintln(w, "Hello, GopherCon SG")    
    })
    if err := http.ListenAndServer(":8080", nil); err != nil {
        log.Fatal(err) //导致 defer 无法正常执行，也不是特别推荐的做法
    }
}
```

> os.exit  defer

### Never start a goroutine without knowning when it will stop

> 不应该启动 goroutine，如果不知道它什么时候结束（管住它的生命周期的结束）
>
> 应该知道什么时候会停止，否则就不应该启动。

```go
//Block waiting to either receive from the goroutine's 
package main

import (
    "fmt"
    "net/http"
    _ "net/http/pprof"
)

func main() {
    mux :=  http.NewServeMux()
    mux.HandleFunc("/", func(resp http.ReponseWriter, req *http.Request) {
        fmt.Fprintln(resp, "Hello, QCon!")
    })
    go http.ListenAndServe("127.0.0.1:8001", http.DefaultServeMux) //debug
    http.ListenAndServe("0.0.0.0:8080", mux) //app traffic
}
```

Any time you start a Foroutine you must ask yourself:
- when will it terminate?（啥时候结束，如果结束了，让它的调用者感知到）
- what could prevent it from termuinating?（如何能够让它结束）

这个简单的应用程序在两个不同的端口上提供 http 流量，端口 8080 用于应用程序流量，端口 8001 应用访问 /debug/pprof 端点。

```go
package main

import (
    "fmt"
    "net/http"
    _ "net/http/pprof"
)

func main() {
    mux := http.NewServeMux()
    mux.HandleFunc("/", func(resp http.ResponseWriter, req *http.Resquest) {
        fmt.Fprintln(resp, "Hello, QCon!")
    })
}
go http.ListenAndServe("127.0.0.1:8001", http.DefaultServeMux) // debug
http.ListenAndServe("0.0.0.0:8080", mux) // app traffic
```

如何优化呢？

第一步：

通过将 serveAPP 和 serveDebug 处理程序分解为各自的函数，我们将它们与 main.main 解耦，我们还遵循了上面的建议，并确保 serveApp 和 serveDebug 将它们的并发性留给调用者。

如果 serveApp 返回，则 main.main 将返回导致程序关闭，只能靠类似 supervisor 进程管理来重新启动。

```go
func serApp() {
    mux := http.NewServeMux()
    mux.HandleFunc("/", func(resp http.ResponseWriter, req *http.Resquest) {
        fmt.Fprintln(resp, "Hello, QCon!")
    })
    http.ListenAndServe("0.0.0.0:8080", mux)
}

func serveDebug() {
    http.ListenAndServe("127.0.0.1:8001", http.DefaultServeMux)
}

func main() {
    go serveDebug() //如果退出了，仍然感知不到
    serveApp() //如果挂掉，进程就会退出了，可通过 supervisor 自动拉起
}
```

然而，serveDebug 是在一个的单独的 goroutine 中运行的，如果它返回，那么所在的 goroutine 将退出，而程序的其余部分继续运行。由于 /debug 处理程序很久以前就停止工作了，所以其他同学会很不高兴地发现他们无法在需要时从你的应用程序中获取统计信息。

```go
func serverApp() {
    mux := http.NewServeMux()
    mux.HandleFunc("/", func(resp http.ResponseWriter, req *http.Resquest) {
        fmt.Fprintln(resp, "Hello, QCon!")
    })
    if err := http.ListenAndServe("0.0.0.0:8080", mux); err != nil {
        log.Fatal(err) // 不是太好的做法
    }
}

func serveDebug() {
    if err := http.ListenAndServe("127.0.0.1:8001", http.DefaultServeMux); err != nil {
        log.Fatal(err) // 不是太好的做法
    }
}

func main() {
    go serveDebug() //在后台执行
    go serveApp() //在后台执行
    select {}
}
```
> ListenAndServer 返回 nil error，最终 main.main 无法退出。
> 
> log.Fatal 调用了 os.Eeit，会无条件终止程序；defers 不会被调用到。

**Onle use log.Fatal from main.main or init functions. **

毛大佬以前写的写法，反面教程：
```go
func main() {
    serveApp() // 没人知道你启动了一个 goroutine，除非你在代码中注释了

    select {}
}

func serverApp() {
    go func() {
        //http.Listen
    }()
}

// 而是应该：

func main() {
    go serveApp() //开启 goroutine 的一定是调用者

    select {}
}

func serverApp() {
    //http.Listen
}
```

推荐写法：
https://github.com/da440dil/go-workgroup
```go
func main() {
    done := make(chan error, 2)
    stop := make(chan struct{})
    go func() {
        done <- serveDebug(stop)
    }()
    go func() {
        done <- serveApp(stop)
    }()

    var stopped bool
    for i := 0; i < cap(done); i++ {
        if err := <- done; err != nil {
            fmt.Println("error:%v", err)
        }
        if !stopped {
            stopped = true
            close(stop)
        }
    }
}

func serve(addr string, handler http.Handler, stop <- chan struct{}) error {
    s := http.server {
        Addr: addr
        Handler: handler,
    }

    go func() {
        <- stop // wait for shop signal
        s.Shutdown(context.Background())
    }()

    return s.ListenAndServe()
}
```

伪代码说明：
```go
func main() {
    go func() {
        done <- serveApp()
    }()

    for i := 0; i < cap(done); i++ {
        <- done
        close(stop)
    }
}

func serveApp(stop chan struct{}) error {
    // goroutine 1
    go func() {
        <- stop
        http.Shutdown()
    }()
    // caller goroutine 2
    return http.Listen()
}
```

